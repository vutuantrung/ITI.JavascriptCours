{"version":3,"sources":["../es2015/src/promises.js"],"names":["chain","delay","combine","promises","result","Promise","all","millisecond","promise","resolve","reject","setTimeout","promiseA","promiseB","firstMethod","console","log","data","secondMethod","someStuff","newData","thirdMethod"],"mappings":";;;;;QAUgBA,K,GAAAA,K;QASAC,K,GAAAA,K;QAcAC,O,GAAAA,O;;AAjChB;;AAIA;;;;;;AAMO,SAASF,KAAT,CAAeG,QAAf,EAAyB;AAC5B,QAAIC,SAASC,QAAQC,GAAR,CAAYH,QAAZ,CAAb;AACA,WAAOC,MAAP;AACH;;AAED;;;;AAIO,SAASH,KAAT,CAAeM,WAAf,EAA4B;AAC/B,QAAIC,UAAU,IAAIH,OAAJ,CAAY,UAAUI,OAAV,EAAmBC,MAAnB,EAA2B;AACjDC,mBAAW,YAAM;AACbF;AACAC;AACH,SAHD,EAGGH,WAHH;AAIH,KALa,CAAd;AAMA,WAAOC,OAAP;AACH;;AAED;;;;AAIO,SAASN,OAAT,CAAiBU,QAAjB,EAA2BC,QAA3B,EAAqC;AACxC,WAAOR,QAAQC,GAAR,CAAY,CAACM,QAAD,EAAWC,QAAX,CAAZ,CAAP;AACH;;AAED;AACA,IAAIC,cAAc,SAAdA,WAAc,GAAY;AAC1B,QAAIN,UAAU,IAAIH,OAAJ,CAAY,UAAUI,OAAV,EAAmBC,MAAnB,EAA2B;AACjDC,mBAAW,YAAY;AACnBI,oBAAQC,GAAR,CAAY,wBAAZ;AACAP,oBAAQ;AACJQ,sBAAM;AADF,aAAR;AAGH,SALD,EAKG,IALH;AAMH,KAPa,CAAd;AAQA,WAAOT,OAAP;AACH,CAVD;;AAYA,IAAIU,eAAe,SAAfA,YAAe,CAAUC,SAAV,EAAqB;AACpC,QAAIX,UAAU,IAAIH,OAAJ,CAAY,UAAUI,OAAV,EAAmBC,MAAnB,EAA2B;AACjDC,mBAAW,YAAY;AACnBI,oBAAQC,GAAR,CAAY,yBAAZ;AACAP,oBAAQ;AACJW,yBAASD,UAAUF,IAAV,GAAiB;AADtB,aAAR;AAGH,SALD,EAKG,IALH;AAMH,KAPa,CAAd;AAQA,WAAOT,OAAP;AACH,CAVD;;AAYA,IAAIa,cAAc,SAAdA,WAAc,CAAUF,SAAV,EAAqB;AACnC,QAAIX,UAAU,IAAIH,OAAJ,CAAY,UAAUI,OAAV,EAAmBC,MAAnB,EAA2B;AACjDC,mBAAW,YAAY;AACnBI,oBAAQC,GAAR,CAAY,wBAAZ;AACAP,oBAAQ;AACJL,wBAAQe,UAAUC;AADd,aAAR;AAGH,SALD,EAKG,IALH;AAMH,KAPa,CAAd;AAQA,WAAOZ,OAAP;AACH,CAVD;;AAYA","file":"promises.js","sourceRoot":"es2015","sourcesContent":["import {\r\n    resolve\r\n} from \"path\";\r\n\r\n/**\r\n * Exécute de manière séquentielle de promises\r\n * \r\n * @param funcs tableau de fonctions retournant une promise\r\n * @return Une promise contenant tous les resultats de promises exécutées\r\n */\r\nexport function chain(promises) {\r\n    var result = Promise.all(promises);\r\n    return result;\r\n}\r\n\r\n/**\r\n * renvoie une promise qui sera resolue au bout d'un nombre définit de millisecondes\r\n * @param millisecond le nombre de millisecondes avant de résoudre la Promise\r\n */\r\nexport function delay(millisecond) {\r\n    var promise = new Promise(function (resolve, reject) {\r\n        setTimeout(() => {\r\n            resolve();\r\n            reject();\r\n        }, millisecond);\r\n    });\r\n    return promise;\r\n}\r\n\r\n/**\r\n * Chaine l'exécution de deux promise et retourne les résultats dans un tableau\r\n * @return une promise retournant le tableau des resultats des deux promise passées en paramètre\r\n */\r\nexport function combine(promiseA, promiseB) {\r\n    return Promise.all([promiseA, promiseB]);\r\n}\r\n\r\n// TEST FUNCTION\r\nvar firstMethod = function () {\r\n    var promise = new Promise(function (resolve, reject) {\r\n        setTimeout(function () {\r\n            console.log('first method completed');\r\n            resolve({\r\n                data: '123'\r\n            });\r\n        }, 2000);\r\n    });\r\n    return promise;\r\n};\r\n\r\nvar secondMethod = function (someStuff) {\r\n    var promise = new Promise(function (resolve, reject) {\r\n        setTimeout(function () {\r\n            console.log('second method completed');\r\n            resolve({\r\n                newData: someStuff.data + ' some more data'\r\n            });\r\n        }, 2000);\r\n    });\r\n    return promise;\r\n};\r\n\r\nvar thirdMethod = function (someStuff) {\r\n    var promise = new Promise(function (resolve, reject) {\r\n        setTimeout(function () {\r\n            console.log('third method completed');\r\n            resolve({\r\n                result: someStuff.newData\r\n            });\r\n        }, 3000);\r\n    });\r\n    return promise;\r\n};\r\n\r\n/*firstMethod()\r\n    .then(secondMethod)\r\n    .then(thirdMethod);*/"]}